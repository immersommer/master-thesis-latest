\chapter{Design}
\label{sec:design}

% Ist das zentrale Kapitel der Arbeit. Hier werden das Ziel sowie die
% eigenen Ideen, Wertungen, Entwurfsentscheidungen vorgebracht. Es kann
% sich lohnen, verschiedene Möglichkeiten durchzuspielen und dann
% explizit zu begründen, warum man sich für eine bestimmte entschieden
% hat. Dieses Kapitel sollte - zumindest in Stichworten - schon bei den
% ersten Festlegungen eines Entwurfs skizziert werden.
% Es wird sich aber in einer normal verlaufenden
% Arbeit dauernd etwas daran ändern. Das Kapitel darf nicht zu
% detailliert werden, sonst langweilt sich der Leser. Es ist sehr
% wichtig, das richtige Abstraktionsniveau zu finden. Beim Verfassen
% sollte man auf die Wiederverwendbarkeit des Textes achten.

% Plant man eine Veröffentlichung aus der Arbeit zu machen, können von
% diesem Kapitel Teile genommen werden. Das Kapitel wird in der Regel
% wohl mindestens 8 Seiten haben, mehr als 20 können ein Hinweis darauf
% sein, daß das Abstraktionsniveau verfehlt wurde.

%\ldots design \ldots

%\todo{write design}

In this chapter, a shielding layer design will be presented to mitigate the pitfalls found in Chapter~\ref{sec:security_analyse}. It consists of the following components：

\textbf{Remote attestation and secret provisioning Infrastructure.} This infrastructure provides a mechanism for securely deploying sensitive user data. Secret management and deployment are offloaded from Kubernetes and Quark Shim to the secret manager. Shield relies on this infrastructure to prove its 
identity to the secret manager and retrieve secrets in a secure manner. This infrastructure addresses vulnerability~\ref{vulnerabilities:1} identified in Chapter~\ref{sec:security_analyse}.

\textbf{Enclave Runtime Measurement.} The module measures the data loaded from the host after the enclave has booted, including binaries, shared libraries, Qkernel's configuration file, and the secret manager's public key. The resulting measurements extend different hashes, including the enclave startup hash, the application startup hash, the runtime binary hash, and 
the application restart hash. The enclave utilizes these hashes to perform integrity checks on the loaded data. As a result, weaknesses ~\ref{vulnerabilities:7}, ~\ref{vulnerabilities:8}, ~\ref{vulnerabilities:9}, and ~\ref{vulnerabilities:11} are mitigated.
 
\textbf{A new pattern for EXEC requests.} This pattern effectively addresses the following pitfalls identified in Chapter~\ref{sec:security_analyse}: issuing unauthorized commands to applications, unrestricted allocation of terminals using kubectl exec -it, and the lack of protection for commands issued by application owners.

\textbf{A mechanism for protecting guest processes' STDIO.} This mechanism ensures the confidentiality and integrity of the STDIO stream of interactive and non-interactive processes. In this case, application logs, execution results of privileged commands, and terminal data streams belonging to the application owner are protected. As such, weaknesses~\ref{vulnerabilities:2}, ~\ref{vulnerabilities:3}, and~\ref{vulnerabilities:5} are solved.

\textbf{System Call Interception and Qkenrel Log Management.} They propose a user-configurable guest system call interception and guest log protection policy to mitigate vulnerabilities~\ref{vulnerabilities:10} and~\ref{vulnerabilities:12}, respectively.
 
In the following, we first give an overview of the architecture in Section~\ref{sec:General_Architecture}. Then, we introduce the remote authentication and provisioning infrastructure in Section~\ref{sec:design_Quark_Attestation_and_Provisioning_Infrastructure}. Subsequent Sections~\ref{sec:Enclave_Runtime_Measurement},~\ref{sec:design_EXEC_Requests},
~\ref{sec:design_STDIO_PROTECTION}, ~\ref{sec:design_STDIO_PROTECTION}, ~\ref{sec:design_Interceptor}, and ~\ref{sec:Qkernel_logger}, we explain the new paradigm for EXEC requests, the 
mechanism for protecting the standard IO of guest processes, the guest system call interceptor, and the guest log management policy, respectively. Finally, we propose modifications to the OCI runtime interface in Section~\ref{sec:Modification_OCI}.


\section{General Architecture}
\label{sec:General_Architecture}
\begin{figure}[htp]
    \centering
    \includegraphics[height=0.3\textheight, width=1\textwidth]{images/genaral_architechture.png}
    \caption[General Architecture]{General Architecture. The green components in the figure are trusted ,and the red components are not trusted.}
    \label{fig:genaral_architechture}
\end{figure}
\todo{fix figure typo issue}

As shown in Figure~\ref{fig:genaral_architechture}, a secure virtual machine provides a trusted execution environment that encapsulates the guest, including the Qkernel and applications. This environment is also referred to as an "enclave." Notably, a shielding layer is added to the Qkernel to prevent adversaries from utilizing the Hcall, Qcall, and Ucall interfaces to launch attacks 
on the enclave. As this shielding layer is part of the Qkernel, its state is protected by the secure virtual machine.

We introduce Securectl for enclave owners. This tool runs in the enclave owner's local environment and provides an interface to interact with the application and control the shielding layer. The secret manager manages application secrets and runs in a confidential VM on the cloud. The enclave owner can authenticate the Secret Manager using remote attestation 
and then uploads secrets through a secure channel. The secret manager can validate the application startup process against the policy uploaded by the application owner and securely sends secrets to the enclave. The shielding layer is responsible for secret deployment and ensures that secrets are not disclosed while the enclave runs.


\section{Quark Attestation and Provisioning Infrastructure}
\label{sec:design_Quark_Attestation_and_Provisioning_Infrastructure}

\begin{figure}[htp]
    \centering
    \includegraphics[width=0.8\textwidth]{images/Qkernel_attestation_infrastructurc.png}
    \caption[Quark Attestation and Provisioning Infrastructure]{Quark Attestation and Provisioning Infrastructure}
    \label{fig:Qkernel_attestation_infrastructurc}
\end{figure}

The Quark attestation and provisioning infrastructure consists of the modules in green in Figure~\ref{fig:Qkernel_attestation_infrastructurc}. It provides the following services for an enclave:

This infrastructure enables the secure deployment of secrets during application startup. Before the application process is launched, the remote attestation and provisioning agent uses the KBS attestation protocol to prove its identity to the secret manager and retrieve secrets. These secrets include shield policy, application startup parameters, environment 
variables, and files. The TEE hardware generates the attestation report required in the protocol with the help of the Qkernel attestation driver. This report contains the enclave startup hash. This hash includes measurements made by the software measurement manager on data loaded from the host, such as application binaries and Qkernel configuration files. 
The secret manager will compare the enclave startup hash with reference values provided by the enclave owner to ensure that the application and enclave are correctly configured. Once obtained secrets, the shielding layer is initialized according to the policy. The application's secrets are deployed to the application process by the secret injector. 
For instance, application startup parameters and environment variables are inserted into the stack of the application process. For file-type secrets, the injector keeps them on enclave memory and creates a sub-filesystem using the Qkernel's virtual filesystem interface. This filesystem is mounted in the /secret directory, and applications can access the secret files through this file system. In this way, we offloaded secret management and deployment from Kubernetes.

Additionally, The infrastructure allows applications to obtain attestation reports at runtime through the guest system call interface. For more information, please refer to Section~\ref{sec:runtime_attesation}.

This section is divided into three parts. Subsection~\ref{sec:design_Secret_Uploading} provides an overview of securely uploading secrets to the secret manager. Subsequently, in Sections~\ref{sec:secure_application_deployment} and~\ref{sec:runtime_attesation}, we discuss the secure deployment of secrets during application startup and how applications can request attestation reports at runtime, respectively. For specific implementations of each module, 
please refer to Chapter~\ref{sec:implementation}.
\begin{figure}[!htb]
    \centering
    \includegraphics[height=0.4\textheight]{images/upload_secret.png}
    \caption[Secret Uploading Workflow]{Secret Uploading Workflow.}
    \label{fig:upload_secret}
\end{figure}

\subsection{Secret Uploading}
\label{sec:design_Secret_Uploading}
The process of uploading secrets to the secret manager requires two steps to be taken by the application owner. Firstly, the application owner needs to attest the secret manager. Secondly, a secure channel must be established for the secret uploading. This process is illustrated in Figure~\ref{fig:upload_secret}. We assume the secret manager is running in the AMD SEV SNP~\ref{fig:upload_secret}. 
Initially，the secret manager generate an RSA key pair for the TLS connection and store the private key in its memory. This key can be regarded as an identifier for the secure channel. To bind the secret manager to the identifier of the secure channel, the hash of the public key is added to the attestation report of the secret manager. Upon receiving the report, 
the application owner requests a certificate chain from the AMD KDC~\cite*{snp_kdc}. The certificate chain is then used to verify the signature of the report. Then using the information in the report, the application owner can ensure that the secret manager is genuine and that the hash of the public key used to establish the TLS matches the hash of the public key 
in the report. By fulfilling these steps, the application owner can determines that the entity on the other side of the secure channel is an expected secret manager. Thus, the channel can safely be leveraged for the secrets uploading.


\subsection{Secure Application Deployment}
\label{sec:secure_application_deployment}
\begin{figure}[!htb]
    \centering
    \includegraphics[height=0.5\textheight]{images/attestation_provisioning.png}
    \caption[Secure Application Deployment Workflow]{Secure Application Deployment. The green components are running in the enclave. The cluster operator is not trusted. The secret manager is responsible for managing the secrets, attesting enclaves, and provisioning the secrets.}
    \label{fig:attestation_provisioning}
\end{figure}

Secure application deployment aims to ensure the confidentiality and integrity of an application's sensitive data and the shielding layer's policy. We propose a new deployment mechanism to achieve this goal, as illustrated in Figure~\ref{fig:attestation_provisioning}.
 
The cluster operator still uses YAML to deploy applications but without including any secrets. Instead, application secrets and shield layer policies are uploaded to the secret manager. The cluster operator only needs to pass the IP address of the secret manager, secrets'URL, and the application binary's name as the environment variable to the 
enclave.

Upon receiving an application creation request, the quark agent creates the application process according to the process specification. Remote attestation and secret provisioning occur after the enclave loads the application binary. This ensures that the secret manager can verify the integrity of the loaded application binary. However, before creating the 
application process, the enclave may need to load and execute multiple binaries to set up the application's runtime environment. Therefore, the enclave will use the name of the application binary in the YAML file to determine if the application binary is loaded. Once loaded, the quark agent will trigger remote attestation and provisioning agent.
 
The agent first requests the Qkernel attestation driver to generate an attestation report. Depending on the type of TEE, the driver will generate different attestation reports. Assuming the enclave runs in AMD SNP, the driver will request the SNP firmware to create the report. The agent will then connect to the secret manager using the IP address in YAML and 
establish a TLS connection. Once the TLS handshake is completed, the agent will complete remote attestation and provisioning according to the KBS attestation protocol. In the authentication phase, it uses an attestation report generated by the Qkernel attestation driver to prove its identity to the secret manager. In the second phase, it will use the URLs in 
the YAML file to construct HTTP GET requests to retrieve the secrets from the secret manager.

The format of the validation report is shown in Figure~\ref*{fig:attestation_report_format}. The report is protected with the VCEK signature and contains SNP firmware's measurements for the VM boot process, tamper-resistant 64-byte user-defined data, host data, VCEK signature, and others.
\begin{figure}[!htb]
    \centering
    \includegraphics[height=0.3\textheight]{images/attestation_report_format.png}
    \caption[SNP attestation report]{SNP attestation report.}
    \label{fig:attestation_report_format}
\end{figure}
The Secret Manager can verify the report signature using the certificate chain required by AMD KDC~\cite*{snp_kdc}. By checking the measurements of the virtual machine boot process, the Secret Manager can confirm that the enclave is using the correct Qkernel binary because the Qkernel is loaded into the enclave memory by Qvisor using 
SNP\_LAUNCH\_UPDATE~\cite*{snp_firmware}
before VM boot. Notably, the code of the shielding layer is part of the Qkernel binary.

The user-defined data in the report is a hash of the enclave startup measurement and metadata required by the KBS protocol~\cite*{kbs_Attestation_protocol}. These metadata include a RAS public key representing the identity of the enclave and an attestation challenge assigned by the secret manager. An explanation of these metadata can be found in section 3. The enclave startup hash is created by 
the software manager and incorporates all the sensitive data that the enclave loads from the host after the enclave starts. This includes Qkernel command line arguments, binaries, shared libraries, and the public key of the secret manager. By comparing the enclave startup hash to a reference hash provided by the enclave owner, the secret manager can confirm that 
the enclave is configured correctly and that only legitimate binaries are loaded. The secret manager's public key is used for application runtime attestation discussed in Section~\ref{sec:runtime_attesation}.

In order to prevent an attacker from hijacking the secret manager's address and impersonating the secret manager, the KBS attestation protocol~\cite*{kbs_Attestation_protocol} requires that the enclave use the secret manager's public key to authenticate the secret manager during the TLS handshake. Currently, we utilize Kubernetes to mount the public key as a file on the application's rootfs. 
The enclave reads the public key into the guest memory and uses it to set up the TLS connection to the secret manager. When an attacker provides the public key of a fake secret manager to the enclave, the TLS handshake fails due to a mismatch between the public key and the certificate of the real secret manager. In other words, the enclave can only establish a 
connection with the fake secret manager.

The KBS attestation protocol~\cite*{kbs_Attestation_protocol} needs improvement. Since all enclaves use a standard Qkernel binary and applications are created from classic images, the attestation evidence cannot uniquely identify an enclave. Instead, the evidence only certifies that the attester is an enclave running in a TEE with the correctly loaded application. 
When a secret manager manages the secrets of multiple stakeholders, an enclave belonging to one stakeholder could steal the secrets of another. To address this issue, the application owner should assign a unique ID to each enclave. This ID should be added to the host data field of the attestation report by Qvisor during enclave setup. This field is immutable after 
launching the enclave, so the ID is bound to the enclave's attestation evidence. When the secret manager receives an enclave's attestation report, it can use this ID to determine the enclave's identity. In the authentication phase of the KBS attestation protocol, the Secret Manager should bind not only the authentication result but also the enclave's ID to the Cookie identifier. 
This way, the secret manager can map the cookie identifier in the attester's resource request message to its attestation result and the enclave's ID. As such, the secret manager can use the ID and the secret owner's policy to determine whether to grant access to a particular secret to the enclave. The attester's resource request URL should have the following 
format: <repository>/<type>/<tag>, where <repository> is similar to the concept of container image repository, <type> is used to distinguish between different resource types, and <tag> is used to distinguish different versions of a resource. The secret manager should assign each user a unique repository and let them specify which enclaves with IDs can access 
this repository. In this way, we effectively avoid cross-leakage of secrets between different stakeholders.

Note that some of the above features are not implemented. Section~\ref{subsec:Limitations} summarizes the limitations of secure application deployment.

\subsection{Application Runtime Attestation Service}
\label{sec:runtime_attesation}

An application may need to authenticate itself to a remote end at runtime. Quark attestation and provisioning infrastructure enable applications to obtain attestation reports through the guest system call interface. Depending on the application's needs, one of three report formats can be 
obtained: an attestation report generated by the TEE hardware and two software attestation reports created by the shielding layer. The latter contains:

\begin{itemize}
    \item Enclave startup hash.
    \item Enclave ID.
    \item Signature.
    \item Sixty-four bytes of application-specified data.
\end{itemize}

The application can sign the software report with a key issued by the secret manager or by a key it provided. The secret manager's key is sent to the enclave along with the application's secret during the creation of the application process. Software reports offer additional possibilities 
for how the application proves its identity to the remote end. In other words, the remote end can verify the report without the assistance of the hardware provider. Upon verification of the report, the remote end can ensure that the application is as expected by using the enclave startup 
measurement. Besides, application-defined data in a software report is tamper-proof, similar to user data in SNP reports. As previously discussed, the enclave ID guarantees that the remote end can determine the application's identity, which prevents secret cross-leakage. The previous 
section has already discussed the major benefits of enclave startup hash. Additionally, it includes the measurement of the secret manager's public key. Therefore, The remote can be sure that the enclave acquired the secrets from the genuine secret manager during application startup and 
correctly initialized the shielding layer and application. In other words, if the shielding layer is initialized with a compromised policy acquired from a fake secret manager, it can no longer guarantee that the secrets provisioned by the remote won't be compromised




\section{Enclave Runtime Measurement}
\label{sec:Enclave_Runtime_Measurement}
\begin{figure}[!htb]
    \centering
    \includegraphics[width=1\textwidth]{images/soft_ware_manager_meausrment.png}
    \caption[Enclave runtime measurement]{Enclave runtime measurement}
    \label{fig:soft_ware_manager_meausrment}
\end{figure}
\todo{fix typo in figure recreating creating}

Enclave runtime measurements are crucial due to the security analysis findings discussed in Chapter~\ref{sec:security_analyse}. However, the AMD SEV SVP does not support enclave runtime measurements~\cite*{snp_firmware}, and the INTEL TDX only allocates four registers for this purpose~\cite*{Intel_tdx_whitepaper}. Consequently, we provide a software measurement 
manager in the shielding layer to measure the data loaded from the host while the enclave is running. As shown in Figure~\ref{fig:soft_ware_manager_meausrment}., The software measurement manager provides the following important hashes:

Enclave startup hash. This value refers to the measures of host-loaded data until the application process starts. This includes the secret manager's key, the Qkernel's configuration file, the application's binary, and the multiple binaries and shared libraries loaded to set up the application environment. Additionally, since each Pod starts a pause container 
first upon startup, the enclave startup hash also contains a measurement of the binaries and shared libraries that were loaded when the pause container was created. The attestation and provisioning agent include this hash in the attestation report, which is conveyed to the secret manager. The secret manager compares the measurement to the reference value provided 
by the enclave owner to ensure the enclave is properly configured. This hash effectively solves the problems 1,2,3 identified in Chapter 3.
\todo{add link}

Application startup reference hash. As shown in the figure, this value records the measure of all binaries and shared libraries during the application's first startup. This measurement is a subset of the enclave's startup measurements and is stored in the enclave's memory. It will be used as a reference value for the application restart hash to ensure the 
integrity of the binary and shared libraries load during the restart. 

Runtime hash. The runtime hash represents a measurement of an executable or shared library loaded in the application runtime. Unlike the enclave startup hash, which is forwarded to the secret manager, the runtime hash is verified by the software manager. The shielding layer's policy holds reference hashes, as shown in Figure~\ref{fig:measurement}. In this case, 
the software measurement manager measures a binary and compares the result with the reference value from the policy. If the two values differ, the enclave will panic. This ensures the correct shared library or executable is loaded during application runtime.
\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.8\textwidth]{images/measurement.png}
    \caption[Reference value in shielding layer's policy for runtime hashes]{Reference value in shielding layer's policy for runtime hashes}
    \label{fig:measurement}
\end{figure}

Application restart hash. When the application crashes and restarts, the software measurement manager measures the binaries and shared libraries. The resulting application restart hash will be compared with the application startup reference hash before launching the application process. If the two do not match, the Enclave panics. In this way, the enclave 
ensures that the host data loaded at restart is the same as the data from the first application startup. The application startup reference hash is a subset of the enclave's startup hash, checked by the secret manager. Thus comparing the two hashes ensures the integrity of the binaries and shared libraries loaded at application restart. 

Regarding obtaining the reference values for enclave startup hash and runtime hashes, we implemented an enclave mode called Development. When running in this mode, the enclave will print these hashes to the Qkernel log on the host. The enclave owner should run the enclave in a trusted environment to obtain these reference values.

\section{New Pattern for EXEC Requests}
\label{sec:design_EXEC_Requests}
\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.8\textwidth]{images/new_pattern_of_exec.png}
    \caption[New Pattern for EXEC Requests]{New Pattern for EXEC Requests}
    \label{fig:new_pattern_of_exec}
\end{figure}

We propose a new pattern for EXEC requests to address issues \todo{add ref} and \todo{add ref} identified in the security analysis. As illustrated in Figure~\ref{fig:new_pattern_of_exec}, The design divides EXEC requests into two categories, namely privileged and unprivileged EXEC requests. Privileged EXEC requests are issued by privileged users 
(i.e., enclave owners), while untrusted entities issue unprivileged requests. An untrusted entity here refers to someone other than the enclave owner. Privileged and non-privileged users send privileged or non-privileged requests to the enclave using securectl or kubectl, respectively. Both requests
are redirected to the enclave through the Kubernetes. Upon receiving an EXEC request, the Quark agent forwards it to the Exec request checker. According to the enclave policy, the Exec request checker will authenticate and access control the request. The Quark agent will decide whether to create the 
EXEC process based on the result returned by the EXEC request checker.






\begin{figure}[!htb] 
    \begin{subfigure}[b]{0.3\linewidth}
      \centering
      \includegraphics[width=0.9\linewidth]{images/exec_policy.png} 
      \caption{Policy for EXEC requests} 
      \label{fig:exec_policy} 
      \vspace{4ex}
    \end{subfigure}%% 
    \begin{subfigure}[b]{0.6\linewidth}
      \centering
      \includegraphics[width=0.9\linewidth]{images/algo_for_path_checking.png} 
      \caption{Algorithm for validating command parameters against directory whitelist} 
      \label{fig:algo_for_path_checking} 
      \vspace{4ex}
    \end{subfigure} 
    \caption{Policy for EXEC requests and algorithm for validating command parameters}
    \label{fig3} 
\end{figure}


The policy used by the exec request checker is in Figure~\ref{fig:exec_policy}. This policy is part of the enclave policy. Each user level possesses an allowlist of commands, "allowed\_cmd," and an allowlist of directories, "allowed\_dir." The command allowlist specifies what commands the user can issue, while the 
directory allows list controls which directories a command can access. When an EXEC request is received, the EXEC checker examines all path-like strings in the command argument and verifies if they exist in the directory allowlist. The EXEC checker also checks whether the current working directory of 
a no-arguments command is a subpath of a directory in the directory allowlist so that the command can only be executed in some specific directories. Notably,  directory whitelisting does not apply to terminal allocation commands like /bin/sh, /bin/bash, and sh. This permits users to allocate a terminal 
from any directory. For instance, this policy enables privileged users to issue cat, ls, and /bin/sh commands. The cat and ls commands are restricted to the /var directory and its subdirectories. Therefore, any attempt to execute commands in other directories (e.g., cat / and cat /bin) will be denied. 
On the other hand, since /bin/sh is included in the command allowlist, privileged users can allocate a terminal. Moreover, if a privilege level's command whitelist is empty, all commands issued by the user with this privilege level will be rejected.



The EXEC checker employs the algorithm presented in~\ref{fig:algo_for_path_checking} to validate the command parameters. It is important to note that the command and its arguments are conveyed as an array of strings from the user to the enclave. The first element of the array represents the command, and the subsequent elements 
correspond to the command's arguments. Consequently, the algorithm iterates through this array to inspect all the command's arguments, capturing absolute and relative paths. Absolute paths encompass strings beginning with '/,' whereas relative paths are the strings containing '.'' or '/.' Following 
this, the algorithm utilizes the command's current working directory to convert relative paths into absolute paths. Finally, it checks all paths against the directory allowlist. It returns false if a path is not a subpath defined in the policy.


\subsection{Protection for Privileged Exec Request}
\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.4\textwidth]{images/exec_frame.png}
    \caption[Frame structure  for protecting privileged exec request]{Frame structure  for protecting privileged exec request}
    \label{fig:exec_frame}
\end{figure}
The frame structure shown in Figure~\ref{fig:new_pattern_of_exec} protects privileged commands and distinguishes them from non-privileged commands. The frame structure encapsulates the string "Privileged," the AES-GCM encrypted payload, the AES-GCM~\cite*{aes_gcm} random number (nonce) used for payload decryption, and the authentication tag. 
The plaintext payload contains the keyword "Privileged," the session ID, a counter,  the Linux command, and its parameters. K8S and the Open Container Initiative require that commands and their parameters in EXEC requests be passed as string vectors. For example, ["cat", "/var/log"]~\cite*{k8s}. As such, 
the encrypted payload, nonce, and tag in the frame structure are encoded in base64, and the frame is passed as a string array to the enclave via the Kubernetes API. Note that the string array is part of the EXEC request process specification called args (See section\todo{add ref}). Upon receiving an EXEC request, 
the EXEC request checker can determine if the request is privileged by viewing the first element of the arg array. If the element is the keyword Privileged", the request will be classified as privileged.

AES-GCM~\cite*{aes_gcm} ensures the confidentiality, authenticity, and integrity of privileged commands and their arguments. Besides, it is easy to deploy, requiring only a shared key. After a successful remote attestation, a key is shared between the application owner and the enclave. The application owner can 
use this key to encrypt privileged commands and their parameters. When the enclave receives a privileged request, the exec request checker can use the key to confirm that the request was generated by a privileged user who knows the key (authentication), verify the request's integrity, and decrypt the 
request.


The monotonic counter and session are designed to prevent reply attacks. Since the privileged Exec requests are transmitted to the enclave by Kubernetes, an attacker can intercept a privileged request and send it continuously to the enclave to interfere with its operation. In addition, it can analyze 
the execution result of an EXEC request. Although the result is encrypted, it may get different results from executing the same command twice. In this case, it may be possible to derive the plaintext by analyzing the changes in the ciphertext. Therefore, we introduce a monotonic counter for 
privileged-level EXEC requests. This counter is assigned by the enclave to privileged users. When the value of the monotonic counter in an EXEC request is smaller than the reference value stored in the enclave, the request is rejected. Since there may be more than one privileged user, it is 
hard to share the counter. Therefore, we introduce sessions. In this case, the enclave will assign each privileged user a random session id and a unique counter. This id and counter are stored in the enclave and will be sent to a privileged user via a secure channel. The privileged user can 
use the session id and counter to construct a privileged EXEC request. Note that the counter is added by one after each EXEC request.

With the session and counter, we avoid the following two reply attacks. First, the attacker sends a request that belongs to an illegal session, i.e., the enclave does not store the session id. Second, the attacker has sent an outdated request to the enclave. This means that the counter value in a 
request is less than the current counter value recorded in the enclave for the requested session ID. In this case, the enclave will refuse to execute it.

\subsection{Session Assignment and Policy Updates}
\begin{figure}[!htb]
    \centering
    
    \begin{minipage}{0.9\textwidth}
    \begin{subcolumns}[0.62\textwidth]
      \subfloat[Workflow of session assignment\label{fig:session_base_auth}]{\includegraphics[width=\subcolumnwidth]{images/session_base_auth.PNG}}

    \nextsubcolumn[0.33\textwidth]
      \subfloat[Frame structure  for session allocation\label{fig:session_allocation}]{\includegraphics[width=\subcolumnwidth]{images/session_allocation.PNG}}

    \nextsubfigure
      \subfloat[Frame structure  for policy updates\label{fig:policy_frame}]{\includegraphics[width=\subcolumnwidth]{images/policy_frame.PNG}}
    \end{subcolumns}
    \end{minipage}
    
    \caption[Session Assignment and Policy Updates]{Session Assignment and Policy Updates}
    \label{fig:session_policy}
\end{figure}


Figure~\ref{fig:session_base_auth} demonstrates how a privileged user gets a session. The privileged user submits a login request using securectl in the login phase. The login request is a privileged EXEC request with the format visualized in Figure~\ref{fig:session_allocation}. Instead of a real Linux command, the keyword Login and a random number 
are used as the command and parameter. The random number is used to prevent reply attacks. After the enclave verifies and decrypts the encrypted payload, it checks the command in the payload. If the command is the keyword Login, it assigns a session ID and a unique counter to the privileged user. 
These two values are stored in the enclave and returned to securectl securely. Specifically, it creates a process when that EXEC request is received. However, the keyword "Login" is not a Linux command. Thus, the enclave replaces the command executed by the exec process with" ls." Once the process 
completes running ls and writes the result to its STDOUT, the STDIO shield will intercept the data and replaces it with the session ID and counter. Since the login request is privileged, the STDIO shield will encrypt the data before sending it to the user. 

When the keyword "enabale\_policy" is true in the enclave policy, privileged users can use securectl to update the enclave policy. Similar to the session allocation request, the policy is updated by sending a privilege-level command to the enclave. The format of the command can be found in~\ref{fig:policy_frame}. Unlike 
the session request's payload, it uses the keyword policy-update as the command, with the new enclave policy as the command's argument

\section{Guest User Space Process STDIO Protection}
\label{sec:design_STDIO_PROTECTION}
The enclave generates guest user-space processes based on process specifications for application creation and EXEC requests. These processes' standard input and output are either tty (Terminal IO) or named pipe (Normal IO), depending on the value of 
the Terminal keyword in the specification. As per our security analysis in Chapter 3, the results of application logs and EXEC requests are returned by the process's standard output or standard error streams. Since the standard output and errors 
are redirected to the containerd, cryptographic protection of the standard output and errors for application processes and privileged EXEC processes is essential.

On the other hand, when STDIO of these processes is of the TERMINAL type, the communication between the user and the processes occurs via the terminal IO redirection thread in quark-shim and the tty driver in the host kernel. This means that any 
commands sent by the privileged user and the command execution results are visible to untrusted entities. Specifically, user commands are transmitted via STDIN to the process, which returns the result to the user via STDOUT or STDERR. Consequently, 
when the STDIO type of the process is TERMINAL, encryption is necessary to protect the stdin.

\subsection{Distinguish the STDIO type of the processes}
Encrypting the STDIO of all processes is not a viable solution for several reasons. Firstly, it would impede non-privileged users from accessing the execution results of non-privileged EXEC requests. In addition, when the enclave is running in 
developer mode, application owners may opt out of encrypting the STDIO of the application as it would use kubectl for viewing application logs or issuing commands. Consequently, we classify the file descriptors used as a guest user process's STDIO 
by the process type:

\begin{itemize} \captionof{enumcnt}{List of file descriptor type used as a guest user process's STDIO}\label{dolist}
    \item Application\_Normal\_IO\_STDIN: the application process's STDIN file descriptor for the normal io 
    \item Application\_Normal\_IO\_STDOUT: the application process's STDOUT file descriptor for the normal io 
    \item Application\_Normal\_IO\_STDERR: the application process's STDERR file descriptor for the normal io 
    \item Application\_Termianl\_IO:  the application process's STDIO file descriptor of tty type 
    \item Privileged\_EXEC\_Process\_With\_Terminal\_IO: privileged EXEC process's STDIO file descriptor of tty type
    \item Unprivileged\_EXEC\_Process\_With\_Terminal\_IO: unprivileged EXEC process's STDIO file descriptor of tty type 
    \item Privileged\_EXEC\_Process\_With\_Normal\_IO\_STDIN: privileged EXEC process's STDIN file descriptor for the normal io 
    \item Privileged\_EXEC\_Process\_With\_Normal\_IO\_STDOUT: privileged EXEC process's STDOUT file descriptor for the normal io.
    \item Privileged\_EXEC\_Process\_With\_Normal\_IO\_STDERR: privileged EXEC process's STDERR file descriptor for the normal io
    \item Unprivileged\_EXEC\_Process\_With\_Normal\_IO\_STDIN: non-privileged EXEC process's STDIN file descriptor in the normal io 
    \item Unprivileged\_EXEC\_Process\_With\_Normal\_IO\_STDOUT. non-privileged EXEC process's STDOUT file descriptor for the normal io
    \item Unprivileged\_EXEC\_Process\_With\_Normal\_IO\_STDERR: non-privileged EXEC process's the stderr file descriptor for the normal io.
    \item Login\_EXEC\_Process\_STDIN: STDIN belonging to the Login exec process
    \item Login\_EXEC\_Process\_STDERR: STDOUT of the Login exec process
    \item Login\_EXEC\_Process\_STDOUT: STDERR of the Login exec process
    
\end{itemize}

In cases where the STDIO type of the application process is terminal, a tty slave will be used for STDIN, STDOUT, and STDERR. The type of this tty slave is Application\_Termianl\_IO.  In contrast, if it is Normal\_IO (named pipe), then the STDIN, 
STDOUT, and STDERR will correspond to Application\_Normal\_IO\_STDIN, Application\_Normal\_IO\_STDOUT, and Application\_Normal\_IO\_STDERR, respectively. The unprivileged EXEC process's STDIO is not encrypted by default. For standard streams of 
application and privileged EXEC processes, the enclave allows the application owner to specify a policy to decide whether they should be cryptographically protected.
\begin{figure}[htp]
    \centering
    \includegraphics[scale=0.5]{images/differenciate_fds.png}
    \caption[Distinguish file descriptor type used as guest user processes' STDIO]{Distinguish file descriptor type used as guest user processes' STDIO}
    \label{fig:differenciate_fds}
\end{figure}

As shown in Figure~\ref{fig:differenciate_fds}, when creating a process and configuring its STDIO, quark-agent generates file descriptor records for STDIN, STDOUT, and  STDERR within the inode tracking table. Each record comprises two elements - the inode id and the file descriptor type, which 
is presented in List~\ref{dolist}. In cases where the process's STDIO type is terminal, only a single record is created since the STDIN, STDOUT, and STDERR file descriptors correspond to the same inode, the inode of the tty slave. When a process 
reads/writes to its STDIO, the shielding layer uses the file descriptor (fd) to obtain the corresponding inode id and retrieves the information from the inode tracking table. Following that, the shielding layer processes the fd’s data based on the 
shielding layer policy, process type, and STDIO type of the process.
  
\subsection{Normal STDIO Protection}

\begin{figure}[htp]
    \centering
    \includegraphics[width=0.8\textwidth]{images/normorl_io.png}
    \caption[Normal STDIO Protection Workflow]{Normal STDIO Protection Workflow}
    \label{fig:normorl_io}
\end{figure}


When it comes to non-interactive applications and EXEC processes, their process's STDIO type falls under Normal IO. In such instances, safeguarding the confidentiality and integrity of data in STDERR and STDOUT of the application and privileged-level 
EXEC processes is vital. To achieve this objective, the Normal STDIO shield utilizes a frame structure that protects the STDOUT and STDERR cryptographically, as shown in Figure~\ref{fig:normorl_io}. This structure includes an encrypted payload, a nonce, and an 
authentication tag. AES-GCM uses the nonce and tag for decryption and authentication. The plaintext payload comprises the information written into STDOUT or STDERR by these processes and a number used to prevent reorder or replay attacks.

Concerning application processes, the number increases sequentially from 0. If a privileged user uses securectl to access an application's logs, this number is utilized to verify whether the log has been reordered or lost. For privileged-level 
EXEC processes, this number is the counter's value in the EXEC request. After receipt of the request's result, securectl compares the reference value and the number in the payload to prevent the replay attack.


\subsection{Terminal STDIO Protection}

\begin{figure}[htp]
    \centering
    \includegraphics[width=0.6\textwidth]{images/terminal_shiled2.png}
    \caption[Terminal STDIO Protection in case of using Host Kenrel TTY Driver]{Terminal STDIO Protection in case of using Host Kenrel TTY driver}
    \label{fig:terminal_shiled2}
\end{figure}

For interactive applications and EXEC processes, the process's STDIO type is terminal. The goal is to ensure the confidentiality and integrity of data in STDIN, STDOUT, and STDERR of the application and privileged EXEC processes. Achieving this 
requires end-to-end encryption and decryption of the process's STDIO, as shown in Figure~\ref{fig:terminal_shiled2}. This involves encrypting the data written to STDIN on the securectl side and decrypting it in the enclave. STDOUT and STDERR data is encrypted in the enclave and decrypted in the 
securectl. However, implementing end-to-end encryption is complex, as the terminal I/O redirection thread is responsible for filtering the signals from the user and sending them to the enclave. The signals are passed in ASCII code format to the 
thread. When securectl encrypts the data written to STDIN, the redirection thread can no longer filter the signals. To address this issue, the terminal I/O forwarding thread was merged into the normal IO shield in the enclave. Specifically, once 
the encrypted data arrives in the enclave, the Normal IO shield reads the data from the named piped that represents process STDIN, decrypts it, filters out possible signals, and forwards the rest of the data to the tty master.

Since the system still uses the host kernel tty driver, everything written to the tty driver must be encrypted. This affects the enclave's performance. Furthermore, the tty driver's inability to process encrypted data will result in the terminal 
failing to work. For data written to the tty slave, the tty driver needs to translate each line feed (\textbackslash n) into a carriage return followed by a line feed (\textbackslash r\textbackslash n). This editing is required because the user-side terminal needs these two characters 
to start a new line of text. Also, for data written to the tty master, the tty driver will buffer it. Only when the user presses the enter key (\textbackslash r) it copies the buffered data to the tty slave. Since all data written to the tty driver is encrypted, 
it cannot process the data anymore.

\begin{figure}[htp]
    \centering
    \includegraphics[width=0.8\textwidth]{images/terminal_shiled3.png}
    \caption[Terminal STDIO Protection in case of using Qkernel TTY driver]{Terminal STDIO Protection in case of Qkernel TTY driver}
    \label{fig:terminal_shiled3}
\end{figure}

To resolve this, as shown in Figure~\ref{fig:terminal_shiled3}, a tty driver with functionality similar to the host kernel tty driver has to be implemented in the enclave. This tty driver will be responsible for character echoing, translating between line feeds and carriage returns, and buffering 
the data written to the tty master. When a guest user-space process writes to its STDOUT, the write system call handler redirects the data to a tty slave. The tty driver processes the data, sends it to the tty master, and then notifies the shielding 
layer to start processing it. The shielding layer encrypts the data read from the tty master and sends it to Securectl via the Qcall interface. Securectl then decrypts the data and sends it to the user.

Note that this design has yet to be implemented due to its complexity. As such, it poses two issues. First, the logs of the interactive application are in plaintext, and second, anyone can use kubectl attach -it to connect to the interactive 
application and issue commands. Therefore, as a temporary mitigation, the data written to the STDOUT and STDERR of the interactive application process is encrypted. In this case, the shielding layer encrypts the data before writing it to tty slave 
using ucall, ensuring that the application logs flowing from the interactive application STDOUT or STDERR are encrypted. Although an attacker can connect to the application and issue commands using kubectl attach -it, they will not obtain any 
valuable information because the results returned by the application are encrypted.

\section{System Call Interceptor}
\label{sec:design_Interceptor}
To control the available system calls for guest user space processes, we implemented a system call interceptor in the Qkernel, as illustrated in Figure~\ref{fig:syscall_interceptor}. When a process calls a system call, the CPU jumps to the guest system call entry point. 
This entry point is responsible for finding the system call handler in the Qkernel based on the system call ID. However, before it does so, it must call the interceptor. Based on the shielding layer's policy, the interceptor decides whether the 
system call is allowed. If the system call is not permitted, the guest system call entry point returns EPERM directly to the user state process instead of calling the system call handler.

\begin{figure}[htp]
    \centering
    \includegraphics[width=0.8\textwidth]{images/syscall_interceptor.png}
    \caption[System Call Interceptor Workflow]{System Call Interceptor Workflow}
    \label{fig:syscall_interceptor}
\end{figure}

The interceptor policy is displayed in Figure~\ref{fig:policy_system_call}. The application owner can turn the interceptor on or off using the keyword enable. The keyword mode determines the system interceptor's mode, which can be ContextBased or GlobalBased. When the system 
interceptor mode is GlobalBased, it is valid for all guest processes. On the other hand, if ContextBased is enabled, the system interceptor only works for the application process. This is possible because the system interceptor records the 
application process's ID. Considering that there may be multiple processes in the guest user space, such as application processes and EXEC processes. It is strongly recommended that the application owner use the mode GlobalBased. Currently, the 
system interceptor supports only one action, ScmpActErrno, i.e., when the triggered system call's ID is not in the allowlist called syscalls, the system call will be rejected
\begin{figure}[htp]
    \centering
    \includegraphics[scale=0.3]{images/policy_system_call.png}
    \caption[System Call Interceptor's Configuration in Shielding Layer Policy]{System Call Interceptor's Configuration in Shielding Layer Policy}
    \label{fig:policy_system_call}
\end{figure}

\section{Qkernel Log Manager}
\label{sec:Qkernel_logger}
Section~\ref{sec:Qkernel_Log_Misconfiguration} of the security analysis discussed the consequences of misconfiguring the Qkernel logging system. Currently, Quark uses a global file to configure the Qkernel and Qvisor. Users can set the logging levels for both using the keyword 
"LogLevel" in this file. Quark supports five logging levels: OFF, ERROR, INFO, DEBUG, and TRACE, where OFF means shutting down the logging system (minimum logging level) and TRACE means printing the most detailed log (maximum logging level). 
Since Qkernel and Qvisor use the same file to configure logging levels, the logging levels are the same for both. However, in confidential computing, Qkernel and Qvisor belong to the application owner and the cloud operator, respectively. They 
have different interests and do not trust each other. For example, to resolve errors quickly, the cloud operator requires the log level in Qvisor to be set to TRACE, while the application owner requires the log level in Qkernel to be OFF (does 
not print any logs) to protect the confidential information in the enclave. In the current architecture, Quark cannot satisfy both requirements.

\begin{figure}[htp]
    \centering
    \includegraphics[width=0.8\textwidth]{images/qkernel_Log_config.png}
    \caption[Qkernel Log Configuration in Shielding Layer Policy]{Qkernel Log Configuration in Shielding Layer Policy}
    \label{fig:qkernel_Log_config}
\end{figure}

For this reason, we offload the configuration of the Qkernel logging system from the global configuration file. As shown in Figure~\ref{fig:qkernel_Log_config}, the application owner can configure the Qkernel logging system in the enclave policy. This configuration consists 
of two keywords, enabled and allowed\_max\_log\_level. The keyword allowed\_max\_log\_level represents the maximum log level that the Qkernel can print. For example, when allowed\_max\_log\_level is the INFO, Qkernel only prints logs with the level INFO, 
ERROR. When the keyword ENABLE is false, the Qkernel logging system will use the default log level from the global file. In addition, enclave policy is passed to the enclave during application deployment. Before the enclave gets the policy, the 
enclave uses the default log level OFF.


\section{Modification to OCI}
\label{sec:Modification_OCI}

\subsection{Extending the container lifecycle to support confidential computing}
The container lifecycle definition in the OCI RUNTIME specification~\cite*{oci-runtime-spec} lacks support for remote attestation and the protection for application’s STDIO. In confidential computing, the relying party uses the remote 
attestation mechanism to verify the user-specified program and supply it with secrets. The types of secrets include environment variables, command line arguments, and files. Also, as known from Chapter~\ref*{sec:security_analyse}, the application 
process STDIO needs to be protected. In this section we first give the definition of container runtime and enclave in the context of confidential computing. Then we will propose modifications to the container lifecycle


\subsubsection{Definition of Runtime and Enclave in Confidential Computing}

Currently, the container runtime in the OCI runtime specification~\cite*{oci-runtime-spec} refer to a runtime environment used to create containers. For a VM based container runtime, it includes the shim process, the hypervisor, and the components 
inside the guest that are used to create and manage the container. For example, in the kata container, the three components correspond to kata-shim, qemu, and kata-agent, respectively. However, in confidential computing, the guest runs in an 
encrypted virtual machine. This means that the components inside the guest are trusted, while the shim process and hypervisor are not trusted. Therefore, we redefine runtime as untrusted runtime components, e.g., kata-shim and qemu. 
In addition, we refer to the components that run in trusted environments for creating containers as enclaves in general, e.g., kata agent, guest kernel, etc.

\subsubsection{Modification to Container Lifecycle}
We make the following changes to the container lifecycle. Note that the bold text in the list is the part we modified, the rest is copied from OCI RUNTIME SPECIFICATION~\cite*{oci-runtime-spec}.

\begin{enumerate}
    \item OCI compliant runtime's create command is invoked with a reference to the location of the bundle and a unique identifier.
    \item The container's runtime environment and enclave MUST be created according to the configuration in config.json. If the runtime is unable to create the environment specified in the config.json, it MUST generate an error. While the resources requested in the config.json MUST be created, the user-specified program (from process) MUST NOT be run at this time. Any updates to config.json after this step MUST NOT affect the container
    \item The prestart hooks MUST be invoked by the runtime. If any prestart hook fails, the runtime MUST generate an error, stop the container, and continue the lifecycle at step 16
    \item The createRuntime hooks MUST be invoked by the runtime. If any createRuntime hook fails, the runtime MUST generate an error, stop the container, and continue the lifecycle at step 16.
    \item The createContainer hooks MUST be invoked by the runtime. If any createContainer hook fails, the runtime MUST generate an error, stop the container, and continue the lifecycle at step 14.
    \item Runtime's start command is invoked with the unique identifier of the container.
    \item The startContainer hooks MUST be invoked by the runtime. If any startContainer hook fails, the runtime MUST generate an error, stop the container, and continue the lifecycle at step 14.
    \item \textbf{The Enclave receives the runtime’s start request and constructs a process for the user-specified program, as specified by process. If this hook fails, the enclave MUST generate an error, stop the container, and continue the lifecycle at step 16}
    \item \textbf{The enclave Must invoke the application launch measurement hook if the user-specified program’s binary is loaded from the host. If this hook fails, the enclave MUST generate an error, stop the container, and continue the lifecycle at step 16.}
    \item \textbf{The attestation and provisioning hook MUST be invoked within the enclave when the enclave finish loading the program’s binary. If this hook fails, the enclave MUST generate an error, stop the container, and continue the lifecycle at step 16.}
    \item \textbf{The process for the user-specified program enters user space and starts to run.}
    \item \textbf{The enclave MUST invoke the runtime measurement hook when the program process loads binary or shared library from the host. If this hook fails, the enclave MUST generate an error, stop the container, and continue the lifecycle at step 16}
    \item \textbf{The enclave must invoke the STDIO protection hook when the program/exec process reads or writes data from its standard IO. If this hook fails, the enclave MUST generate an error, stop the container, and continue the lifecycle at step 16}
    \item The poststart hooks MUST be invoked by the runtime. If any poststart hook fails, the runtime MUST log a warning, but the remaining hooks and lifecycle continue as if the hook had succeeded.
    \item The container process exits. This MAY happen due to erroring out, exiting, crashing or the runtime's kill operation being invoked.
    \item Runtime's delete command is invoked with the unique identifier of the container.
    \item The container MUST be destroyed by undoing the steps performed during create phase (step 2).
    \item The poststop hooks MUST be invoked by the runtime. If any poststop hook fails, the runtime MUST log a warning, but the remaining hooks and lifecycle continue as if the hook had succeeded.    
  \end{enumerate}


  The application launch measurement hook should be called when the enclave loads the application binary from the host. This hook must be executed in the enclave namespace. It is responsible for measuring the application binaries loaded from the 
  host. The attestation and provisioning hook will send the measurement results to the relying party as part of the attestation report for integrity check. Note that the TEE hardware must measure this hook as part of the enclave container runtime 
  component.
  

  The attestation and provisioning hook must be invoked after the enclave loads the application binary but before the application process stack is set. This hook provides a mechanism for the enclave to authenticate itself to the relying party and 
  retrieve the secret. We recommend that runtime developers implement a KBS Client in the enclave based on the KBS attestation protocol as the remote attestation and provisioning hook. We provide a reference implementation in Chapter 5. Note that 
  this hook must be executed in the enclave namespace. Alternatively, it can be measured by the TEE hardware as part of the enclave container runtime component or loaded by the host as a binary file. In the latter case, the hook must be measured 
  by the application launch measurement hook. If the application binary is loaded from the host, the attestation report the hook sends to the relying party must include the application launch measurement hook's measurement. After the attestation 
  and provisioning hook retrieves the secret, it should push the environment variable and application parameter type secret into the application process's stack. For the file type secret, it should store it within the enclave, and implement a 
  mechanism to make it accessible to the application. We provide a reference implementation in Section 5.
  \todo{add link  in Section 5}

  The runtime measurement hook should by called by the enclave should call  when the application loads a shared library or binary file from the host at runtime. This hook must be executed in the enclave namespace. It measures the shared libraries or 
  binaries loaded from the host at application runtime. It compares the measurement result with the reference value. If the two do not match, the hook execution fails. In this case, the enclave must generate an error, stop the container, and 
  continue the life cycle at step 16. Note that the reference values are obtained by the attestation and provisioning hook from the relying party during application deployment. Alternatively, this hook can be measured by the TEE hardware as part 
  of the enclave container runtime component or as a binary file loaded from the host at application startup. In the latter case, this hook must be measured by the application launch measurement hook.
  

  The STDIO protection hook should be called when the application process or privileged exec process reads or writes its STDIO. This hook is responsible for cryptographically protecting the STDOUT and STDERR of the process. It is also responsible 
  for decrypting the data read from stdin when the STDIO type of the process is terminal. A reference can be found in Section~\ref*{sec:design_STDIO_PROTECTION} . Alternatively, this hook can be measured by the TEE hardware as part of the enclave container runtime 
  component or as a binary loaded from the host at application startup. In the latter case, this hook must be measured by the application launch measurement hook.
  
\subsection{EXEC Operating Guidelines}

  There was much discussion in the OCI Runtime spec community about the semantics of EXEC operations. Ultimately, however, the runtime spec decided not to standardize on EXEC operations~\cite*{exec_semantics}. This gives runtime developers more freedom to implement it 
  according to their specific needs. However, in a confidential computing scenario, EXEC opens a backdoor for attackers to steal an application’s secrets running in an Enclave. For this reason, we propose a standardized EXEC operation for the 
  confidential computing scenario.

  We use the proposal for standardizing EXEC operations in Figure~\ref{fig:exec_propose} as a starting point. This proposal was submitted to the OCI Runtime spec forum, but ultimately was not adopted for the reasons mentioned earlier.

\begin{figure}[htp]
    \centering
    \includegraphics[width=0.8\textwidth]{images/exec_propose.png}
    \caption[Proposal for standardizing EXEC operation]{Proposal for standardizing EXEC Operation from~\cite*{exec_proposal} }
    \label{fig:exec_propose}
\end{figure}


  In a confidential computing scenario, exec requests should be divided into two categories, namely privileged  request issued by the application owner and unprivileged requests issued by otherss. We have 2 goals here. First, we want to restrict 
  the commands that users at each privilege can issue to the application following the least privilege principle. Second, we want to protect the commands issued by privileged-level users and its execution results. Therefore, the args in the json file 
  of privileged EXEC requests must be protected. The protection mechanism is discussed in Figure~\ref{fig:new_pattern_of_exec} and in Section~\ref{sec:design_EXEC_Requests}. This mechanism effectively distinguishes between privileged and unprivileged requests and ensures the confidentiality, integrity, 
  and authenticity of commands issued by privileged users. The enclave should authenticate and access control the request before creating the EXEC process. The authentication is done by using a key shared between the privileged user and the enclave. 
  This key is fetch by the attestation and provisioning hook from relying party. The steps for access control are as follows. First the enclave determines the type of the EXEC request by checking if the first element in the args array is Privileged. 
  It then reads the policy and determines whether this command is allowed to be executed. The content of the policy is shown in Figure~\ref{fig:exec_policy}. In particular, the policy is  obtained by the attestation and provisioning hook.  
  The policy specifies the commands that can be executed by users at each privilege and the directories in which these commands has access to. We will provide a reference algorithm for the access control in Chapter 4.
  \todo{add link Chapter 4}

  In addition, to protect the results of privileged-level EXEC requests, the enclave must encrypt the stdout and stderr of privileged-level processes. The encryption mechanism can be found in Section~\ref{sec:design_STDIO_PROTECTION}.
  

\section{Summary}
In this chapter, we present mechanisms for protecting the integrity and confidentiality of a secure application's secrets when it is orchestrated by untrusted k8s. We demonstrate a secure approach to deploying applications, and how to protect 
the confidentiality and integrity of the application's standard flows, restrict the commands users can issue to the application, and propose modifications to the OCI interface. With these approach, applications can be orchestrated in a secure 
manner by untrusted entities. In next chapter, we describe how we implemented this mechanisms .
\cleardoublepage

%%% Local Variables:
%%% TeX-master: "diplom"
%%% End:
