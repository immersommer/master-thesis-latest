\chapter{Quellcodes}
\label{sec:conclusion}

\section{VERHALTENSBESCHREIBUNG FSM}

\begin{lstlisting}[numbers=left,xleftmargin=1em, multicols=2,frame=leftline, basicstyle = \small\ttfamily]
//Verilog HDL for "fc_example", "FSM" "functional"

module FSM (flag_s, flag_z, clk, reset, load, state);

	parameter IDLE = 5'b00000;
	parameter SORT1 = 5'b00001;
	parameter SORT2 = 5'b00010;
	parameter SORT3 = 5'b00011;
	parameter SORT4 = 5'b00100;
	parameter SORT5 = 5'b00101;
	parameter SORT6 = 5'b00110;
	parameter SORT7 = 5'b00111;
	parameter SORT8 = 5'b01000;
	parameter SORT9 = 5'b01001;
	parameter SORT10 = 5'b01010;
	parameter SORT11 = 5'b01011;
	parameter SORT12 = 5'b01100;
	parameter SORT13 = 5'b01101;
	parameter SORT14 = 5'b01110;
	parameter SORT15 = 5'b01111;
	parameter SORT16 = 5'b10000;
	parameter SORT17 = 5'b10001;
	parameter SORT18 = 5'b10010;
	parameter SORT19 = 5'b10011;
	parameter SORT20 = 5'b10100;
	parameter SORT21 = 5'b10101;
	parameter SORT22 = 5'b10110;
	parameter SORT23 = 5'b10111;
	parameter SORT24 = 5'b11000;
	parameter OUTPUT1 = 5'b11001;
	parameter OUTPUT2 = 5'b11010;

	input clk;
	input reset;
	input flag_s;
	input flag_z;
	input load;

	output state;

	reg [4:0] state;
	reg [4:0] next_state;

   always @ (posedge clk or posedge reset)
     if (reset) begin
           state <= IDLE;
     end
     else begin
       state <= next_state;
     end

   always @ (state or flag_z or flag_s or load)
     case (state)
	IDLE		: if (load) begin       //BC0
                      next_state = SORT1;
                end
                else begin
                   next_state = IDLE;
                end
	SORT1	: next_state = SORT2;
	SORT2	: next_state = SORT3;
	SORT3	: next_state = SORT4;
	SORT4	: next_state = SORT5;
    SORT5	: next_state = SORT6;
	SORT6	: if (flag_z) begin
               next_state = OUTPUT2;
              end
              else begin
                next_state = SORT7;
              end
	SORT7	: next_state = SORT8;
	SORT8	: if (flag_z) begin
				next_state = OUTPUT1;
			  end
			  else begin
				next_state = SORT9;
			  end
	SORT9	: next_state = SORT10;
	SORT10	: if (flag_s) begin
				next_state = SORT11;
			  end
			  else begin
				next_state = SORT13;
			  end
	SORT11	: next_state = SORT12;
	SORT12	: next_state = SORT13;
	SORT13	: next_state = SORT14;
	SORT14	: if (flag_s) begin
				next_state = SORT15;
			  end
			  else begin
				next_state = SORT17;
			  end
	SORT15	: next_state = SORT16;
	SORT16	: next_state = SORT17;
	SORT17	: next_state = SORT18;
	SORT18	: if (flag_z) begin
				next_state = OUTPUT2;
			  end
			  else begin
				next_state = SORT19;
			  end
	SORT19	: next_state = SORT20;
	SORT20	: if (flag_s) begin
				next_state = SORT23;
			  end
			  else begin
				next_state = SORT21;
			  end
	SORT21	: next_state = SORT22;
	SORT22	: next_state = SORT17;
	SORT23	: next_state = SORT24;
	SORT24	: next_state = SORT17;
	OUTPUT1	: next_state = IDLE;
	OUTPUT2	: next_state = IDLE;
	default	: next_state = IDLE;
  endcase

endmodule
\end{lstlisting}

\section{VERHALTENSBESCHREIBUNG STEUERLOGIK}
\begin{lstlisting}[numbers=left,xleftmargin=1em, multicols=2,frame=leftline, basicstyle = \small\ttfamily]
//Verilog HDL for "fc_example", "Controllogic" "functional"

module Controllogic (
            state,
            EN_ALU, EN_X, EN_Y, MX_A, MX_B, MX_C, MX_X, MX_Y, SET_S, SET_Z, SUB,
            ram_wr_en, ram_rd_en, ready);
    
    parameter IDLE = 5'b00000;
    parameter SORT1 = 5'b00001;
    parameter SORT2 = 5'b00010;
    parameter SORT3 = 5'b00011;
    parameter SORT4 = 5'b00100;
    parameter SORT5 = 5'b00101;
    parameter SORT6 = 5'b00110;
    parameter SORT7 = 5'b00111;
    parameter SORT8 = 5'b01000;
    parameter SORT9 = 5'b01001;
    parameter SORT10 = 5'b01010;
    parameter SORT11 = 5'b01011;
    parameter SORT12 = 5'b01100;
    parameter SORT13 = 5'b01101;
    parameter SORT14 = 5'b01110;
    parameter SORT15 = 5'b01111;
    parameter SORT16 = 5'b10000;
    parameter SORT17 = 5'b10001;
    parameter SORT18 = 5'b10010;
    parameter SORT19 = 5'b10011;
    parameter SORT20 = 5'b10100;
    parameter SORT21 = 5'b10101;
    parameter SORT22 = 5'b10110;
    parameter SORT23 = 5'b10111;
    parameter SORT24 = 5'b11000;
    parameter OUTPUT1 = 5'b11001;
    parameter OUTPUT2 = 5'b11010;
    
    input  [4:0] state;
    output EN_ALU;
    output EN_X;
    output EN_Y;
    output [1:0] MX_A;
    output [1:0] MX_B;
    output [1:0] MX_C;
    output MX_X;
    output MX_Y;
    output SET_S;
    output SET_Z;
    output SUB;
    
    output ram_wr_en;
    output ram_rd_en;
    output ready;
    
    reg	EN_ALU;
    reg EN_X;
    reg EN_Y;
    reg [1:0] MX_A;
    reg [1:0] MX_B;
    reg [1:0] MX_C;
    reg MX_X;
    reg MX_Y;
    reg SET_S;
    reg SET_Z;
    reg SUB;
        
    reg ram_wr_en;
    reg ram_rd_en;
    reg ready;
    
   always @ (state)
     begin
        EN_ALU = 1'b0;
        EN_X = 1'b0;
        EN_Y = 1'b0;
        MX_A = 2'b00;
        MX_B = 2'b00;
        MX_C = 2'b00;
        MX_X = 1'b0;
        MX_Y = 1'b0;
        SET_S = 1'b0;
        SET_Z = 1'b0;
        SUB = 1'b0;
        
        ram_wr_en = 1'b0;
        ram_rd_en = 1'b0;
        ready = 1'b0;
    
     case (state)
    IDLE: begin
            ready = 1'b1;   // ready if FSM returns to idle state
          end
    SORT1: begin
             MX_C = 2'b00;      //Const0->C
              ram_rd_en = 1'b1;  //read MEM
            end
    SORT2: begin			 
             MX_A = 2'b00;   //MEM->A
             MX_X = 1'b0;    //A->Rx
             EN_X = 1'b1;
           end
    SORT3: begin
             MX_C = 2'b01;   //Const1->C
             ram_rd_en = 1'b1;  //read MEM
           end
    SORT4: begin
             MX_A = 2'b00;  //MEM->A
             MX_Y = 1'b0;   //A->Ry
             EN_Y = 1'b1;
           end
    SORT5: begin
             MX_A = 2'b10;  //Ry->A
             MX_B = 2'b10;  //Const0->B
             EN_ALU = 1'b1;
             SUB = 1'b1;
             SET_Z = 1'b1;
           end
    SORT6: begin
           end
    SORT7: begin
             MX_A = 2'b01;  //Rx->A
             MX_B = 2'b10;  //Const0->B
             EN_ALU = 1'b1;
             SUB = 1'b1;
             SET_Z = 1'b1;
           end
    SORT8: begin
           end
    SORT9: begin
             MX_A = 2'b01;  //Rx->A
             MX_B = 2'b10;  //Const0->B
             EN_ALU = 1'b1;
             SUB = 1'b1;
             SET_S = 1'b1;
           end
    SORT10: begin
            end
    SORT11: begin
              MX_A = 2'b11;  //Const0->A
              MX_B = 2'b00;  //Rx->B
              EN_ALU = 1'b1;
              SUB = 1'b1;
            end
    SORT12: begin
              MX_C = 2'b11;//SUB->C
              MX_X = 1'b1;//C->Rx
              EN_X = 1'b1;				 
            end
    SORT13: begin
              MX_A = 2'b01;  //Rx->A
              MX_B = 2'b10;  //Const0->B
              EN_ALU = 1'b1;
              SUB = 1'b1;
              SET_S = 1'b1;
            end
    SORT14: begin
            end
    SORT15: begin
              MX_A = 2'b11;  //Const0->A
               MX_B = 2'b01;  //Ry->B
              EN_ALU = 1'b1;
              SUB = 1'b1;
            end
    SORT16: begin
              MX_C = 2'b11;  //SUB->C
              MX_Y = 1'b1;   //C->Ry
              EN_Y = 1'b1;
            end
    SORT17: begin
              MX_A = 2'b01;  //Rx->A
              MX_B = 2'b01;  //Ry->B
              EN_ALU = 1'b1;
              SUB = 1'b1;
              SET_Z = 1'b1;
            end
    SORT18: begin
            end
    SORT19: begin
              MX_A = 2'b01;  //Rx->A
              MX_B = 2'b01;  //Ry->B
              EN_ALU = 1'b1;
              SUB = 1'b1;
              SET_S = 1'b1;
            end
    SORT20: begin
            end
    SORT21: begin
              MX_A = 2'b01;  //Rx->A
              MX_B = 2'b01;  //Ry->B
              EN_ALU = 1'b1;
              SUB = 1'b1;
            end
    SORT22: begin
              MX_C = 2'b11;  //SUB->C
              MX_X = 1'b1;   //C->Rx
              EN_X = 1'b1;
            end
    SORT23: begin
              MX_A = 2'b10;  //Ry->A
              MX_B = 2'b00;  //Rx->B
              EN_ALU = 1'b1;
              SUB = 1'b1;
            end
    SORT24: begin
              MX_C = 2'b11;  //SUB->C
              MX_Y = 1'b1;   //C->Ry
              EN_Y = 1'b1;				 
            end				   
    OUTPUT1: begin
               MX_C = 2'b10;  //Const2->C
               MX_B = 2'b01;  //Ry->B
                      
               ram_wr_en = 1'b1;
             end
    OUTPUT2: begin
               MX_C = 2'b10;  //Const2->C
               MX_B = 2'b00;  //Rx->B
                      
               ram_wr_en = 1'b1;
             end
 endcase
 end
    
endmodule
\end{lstlisting}

\section{TESTBENCH TOPZELLE}
\begin{lstlisting}[numbers=left,xleftmargin=1em, multicols=2,frame=leftline, basicstyle = \small\ttfamily]
//Verilog HDL for "fc_example", "Top_tb" "functional"

module Top_tb (load);
    
    parameter CYCLE = 50;
    
// declarations
    wire  [31:0] DATA_MEM_RD;
    wire  [31:0] DATA_MEM_WR;
    wire  [31:0] ADR;
    wire         ready;
    wire         ram_wr_en;
    wire         ram_rd_en;
    
    reg          clk, reset;
    output       load;
    reg          load;
    
// RAM
   Memory MEM(
     .ADR(ADR),
     .DIN(DATA_MEM_WR),
     .DOUT(DATA_MEM_RD),
     .clk(clk),
     .wr_en(ram_wr_en),
     .rd_en(ram_rd_en)
   );
    
// DUT
   Tob_level DUT(
     .ADR(ADR),
     .DIN(DATA_MEM_RD),
     .DOUT(DATA_MEM_WR),
     .clk(clk),
     .reset(reset),
     .ram_wr_en(ram_wr_en),
     .ram_rd_en(ram_rd_en),
     .ready(ready),
     .load(load)
   );
    
// Clock
   initial clk = 1'b0;
   always #(CYCLE/2) clk = ~clk;
    
// Reset
   initial begin
     reset = 1'b1;
     #(3*CYCLE )
     reset = 1'b0;
// special setup for certain state:
// 	 DUT.FSM.state= 15; // LOOP3
   end 
    
// Load-Signal   
   initial begin
     load = 0;
     #(5*CYCLE)
     load = 1;
     #(CYCLE)
     load = 0;
         
     while (ready == 0) begin
       #(CYCLE);
       load = 0;
     end
         
     $finish;
   end
    
// Delay Annotation
// initial begin
// $sdf_annotate("/home2/vlsi00/prz-root/ICPRO/ice/ziyi/units/sdf/ALU_FIXED32.sdf",DUT.Datenpfad.ALU,,);
// end
    
endmodule
\end{lstlisting}
\cleardoublepage

