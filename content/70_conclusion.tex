\chapter{Conclusion and Outlook}
\label{sec:conclusion}

%  Schlußfolgerungen, Fragen, Ausblicke

% Dieses Kapitel ist sicherlich das am Schwierigsten zu schreibende. Es
% dient einer gerafften Zusammenfassung dessen, was man gelernt hat. Es
% ist möglicherweise gespickt von Rückwärtsverweisen in den Text, um dem
% faulen aber interessierten Leser (der Regelfall) doch noch einmal die
% Chance zu geben, sich etwas fundierter weiterzubilden. Manche guten
% Arbeiten werfen mehr Probleme auf als sie lösen. Dies darf man ruhig
% zugeben und diskutieren. Man kann gegebenenfalls auch schreiben, was
% man in dieser Sache noch zu tun gedenkt oder den Nachfolgern ein paar
% Tips geben. Aber man sollte nicht um jeden Preis Fragen, die gar nicht
% da sind, mit Gewalt aufbringen und dem Leser suggerieren, wie
% weitsichtig man doch ist. Dieses Kapitel muß kurz sein, damit es
% gelesen wird.

% \ldots conclusion \ldots

% \todo{write conclusion}

This thesis aims at enabling untrustworthy cloud providers to orchestrate applications within \acrshort{CVM} while ensuring the confidentiality and integrity of applications' data. In particular, to minimize the \acrshort{TCB} of the CVM, \acrshort{pVM} is selected as a starting point.
 
Chapter~\ref{sec:security_analyse} analyzed the vulnerabilities of the OCI runtime interface in confidential computing. To address these issues, Chapter~\ref{sec:design} introduced the OCI runtime interface shield and proposed modifications to the OCI runtime interface. The shield is implemented 
within the \acrshort{CVM} and enforces a policy provided by the application owner on the OCI runtime interface. Figure~\ref{fig:generic_policy} on page \pageref{fig:generic_policy} illustrates an example of such a policy. The shield allows the application owner to verify the state of the \acrshort{CVM}
and securely deploy secrets. While the \acrshort{CVM} is operational, the shield can authenticate and do access control on EXEC requests, encrypts STDIO for the processes running in the \acrshort{CVM}, restricts guest system calls, and manages \acrshort{CVM}'s logs. Additionally, a 
secure client for the application owners is implemented, enabling them to issue privilege commands and update the shield policy.
 
The qualitative analysis in Section~\ref{sec:eva_qualitativ} proved that the system implemented in Chapter~\ref{sec:implementation} can effectively mitigate most issues found in the security analysis. A summary of the qualitative analysis can be found in Table~\ref{tab:eva_qualitativ_summary} on page \pageref{tab:eva_qualitativ_summary}. 
On the other hand, the quantitative analysis in Section~\ref{sec:eva_Quantitative} revealed performance degradation due to the system. This is evident in longer application startup time, 
decreased application throughput, an increased \acrshort{TCB} size, etc. Nevertheless, Quark's \acrshort{TCB} is only one-sixteenth the size of Kata Containers\cite*{Kata-Containers}, highlighting the superiority of the \acrshort{pVM} architecture. The results of the quantitative analysis 
are summarized in Section~\ref{sec:qualitativ_sum} on page \pageref{sec:qualitativ_sum}.
 
Further work is required before the solution can be deployed. For example, running Quark in secure VMs (e.g., Intel TDX~\cite*{Intel_tdx_whitepaper}) and enhancing the remote attestation infrastructure are necessary. The following section provides a detailed discussion of these aspects.


\section{Furture Work}

Chapter~\ref{sec:design} provides solutions to the problems identified through the security analysis in Chapter~\ref{sec:security_analyse}. However, some of these were not implemented since they were out of scope. This includes the secret uploading discussed in 
Section~\ref{sec:design_Secret_Uploading}, the methods to mitigate secret cross-leakage described in Section~\ref{sec:secure_application_deployment} on page \pageref{eq:1}, and the terminal protection outlined in Section~\ref{subsec:design_terminal}. In the next step, the 
priority will be to implement these designs.

Currently, the secret manager operates locally and utilizes a local file system backend to store secrets. However, in the future, the goal is for the secret manager to run in the cloud and manage secrets from multiple stakeholders. Thus, it is necessary to place the secret manager in 
a secure virtual machine and develop a confidential backend. The backend can be memory-based or storage-based. The former is more straightforward because the VM's memory is encrypted. On the other hand, if the latter option is chosen, it is essential to 
incorporate a file system shielding layer~\cite*{file_system_shield} to prevent any leakage of secrets written to the VOLUME.

The remote attestation infrastructure is immature, as Quark can only generate simulated attestation reports. As discussed in Section~\ref{subsec:Limitations}, in this case, the secret manager cannot verify the report's authenticity. Future implementations will have to close this security 
gap.

The performance evaluation in Section~\ref{bench_Interceptor} shows that the guest system interceptor imposes a significant latency overhead. As discussed in Section~\ref{sec:impl_interceptor}, these overheads arise from accessing the vector that holds the system call whitelist and the lock 
that safeguards the vector. In future implementations, a possible solution could involve storing the system call whitelist in eight \texttt{AtomicU64}~\cite*{rust_automic_u64} variables, with each bit in the variable representing a system call ID. Given that Quark consists of a total of 451 system calls, eight variables would suffice. The whitelist can then be accessed using atomic 
operations to circumvent the previously mentioned overhead.

Quark lacks protection for the VM's memory and registers states. Thus, untrusted entities (e.g., virtual machine hypervisors) can gain access to secrets stored within the VM. To tackle this issue, the future implementation must modify Quark's architecture to support either 
AMD SEV SNP~\cite*{SEV_SNP_white_book} or Intel TDX~\cite*{Intel_tdx_whitepaper}.

Quark uses a parevirtualized file system sharing mechanism to share files and volumes stored on the host with applications on the guest. Any changes made to the files by the application are reflected on the host. This poses a security risk because an attacker can access an application's secrets by 
accessing the rootfs of the application on the host. A common approach is implementing a guest filesystem shield to protect inbound and outbound guest data. Those interested in learning more about this topic should refer to~\cite*{file_system_shield}.

Quark lacks authentication to network requests and cryptographic protection for transmitted data, resulting in potential unauthorized access to the application or man-in-the-middle attack~\cite*{Man_in_the_middle_attack}. For instance, attackers can use \emph{kubectl port-forwarding} to connect to an 
application listening on the target port and acquire the application's confidential data or service. A possible solution is implementing a guest network shield that leverages TLS\cite*{tls_record_size} to authorize incoming network requests and provides cryptographic protection for incoming and 
outgoing data. However, this thesis does not cover this type of vulnerability, and readers are encouraged to refer to~\cite*{network_shiled}.

Currently, a \acrshort{CVM} is restricted to running a single application. Attempting to load additional applications into the \acrshort{CVM}  will cause the software measurement manager to panic since the application restart hash does not match the application startup reference hash. 
This prevents the service mesh from working properly since it requires the sidecar container to be run in the \acrshort{CVM}. As such,  future releases should involve an extension of the software measurement manager. In this case, the application owner can specify the loadable containers and their 
reference hashes in the shield policy. This will allow the \acrshort{CVM} to load additional containers. During the loading process, the software measurer will use the container's reference hash to ensure that the loaded container binaries are correct.




\cleardoublepage

